package telegram

import (
	"reflect"
	"testing"
)

func TestNewInlineQueryResultCachedVoice(t *testing.T) {
	t.Run("ok", func(in *testing.T) {
		update := &Update{
			ID:          1337,
			InlineQuery: &InlineQuery{ID: "133733", Query: "bad"},
		}
		answer := NewInlineQueryResultCachedVoice(update)[0]
		voice := "AwA--1"
		expected := &AnswerInlineResult{
			Type:        AnswerInlineTypeVoice,
			ID:          "-autogenerated field-",
			VoiceFileID: &voice,
			Title:       "Good, bad, I'm a guy with a gun",
			Caption:     "Good, bad, I'm a guy with a gun",
		}
		// id is automatically generated, thus far it's no reason to check it
		expected.ID = answer.ID

		if !reflect.DeepEqual(answer, expected) {
			in.Errorf("\nexp: %+v\ngot: %+v", expected, answer)
		}
	})

	t.Run("ok/not-found", func(in *testing.T) {
		update := &Update{
			ID:          1337,
			InlineQuery: &InlineQuery{ID: "133733", Query: "bad12"},
		}

		answer := NewInlineQueryResultCachedVoice(update)[0]
		voice := "AwA--3"
		expected := &AnswerInlineResult{
			Type:        AnswerInlineTypeVoice,
			ID:          "",
			VoiceFileID: &voice,
			Title:       "Come get some!",
			Caption:     "Come get some!",
		}
		expected.ID = answer.ID

		if !reflect.DeepEqual(answer, expected) {
			in.Errorf("\nexp: %+v\ngot: %+v", expected, answer)
		}
	})
}

func TestNewAnswerInline(t *testing.T) {
	update := &Update{
		ID:          1337,
		InlineQuery: &InlineQuery{ID: "133733", Query: "bad"},
	}

	// check only answer identifier
	answer := NewAnswerInline(update)
	expectedID := "133733"
	if answer.ID != expectedID {
		t.Errorf("expected: %v, got: %v", expectedID, answer.ID)
	}
}

func TestUpdate_Type(t *testing.T) {
	for _, entry := range []struct {
		name     string
		in       *Update
		expected UpdateType
	}{
		{"message", &Update{Message: &Message{}}, UpdateTypeMessage},
		{"inline", &Update{InlineQuery: &InlineQuery{}}, UpdateTypeInline},
		{"unknown", &Update{}, UpdateTypeUnknown},
	} {
		t.Run(entry.name, func(in *testing.T) {
			if result := entry.in.Type(); result != entry.expected {
				in.Errorf("expected: %d, got: %d", entry.expected, result)
			}
		})
	}
}
