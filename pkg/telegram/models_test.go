package telegram

import (
	"reflect"
	"testing"
)

func TestNewInlineQueryResultCachedVoice(t *testing.T) {
	originQuotes := Quotes
	defer func() {
		Quotes = originQuotes
	}()
	_ = ReadQuotes(testConfigFile)

	t.Run("ok", func(in *testing.T) {
		update := &Update{
			ID:          1337,
			InlineQuery: &InlineQuery{ID: "133733", Query: "bad"},
		}
		answer := NewInlineQueryResultCachedVoice(update)[0]
		voice := "AwACAgIAAxkDAAMgX3"
		expected := &AnswerInlineResult{
			Type:        AnswerInlineTypeVoice,
			ID:          "-autogenerated field-",
			VoiceFileId: &voice,
			Title:       "I've got a bad feeling about this",
			Caption:     "I've got a bad feeling about this",
		}
		// id is automatically generated, thus far it's no reason to check it
		expected.ID = answer.ID

		if !reflect.DeepEqual(answer, expected) {
			in.Errorf("\nexp: %+v\ngot: %+v", expected, answer)
		}
	})

	t.Run("ok/not-found", func(in *testing.T) {
		update := &Update{
			ID:          1337,
			InlineQuery: &InlineQuery{ID: "133733", Query: "bad12"},
		}

		answer := NewInlineQueryResultCachedVoice(update)[0]
		voice := "AwACAgIAAxkDAAMRX3"
		expected := &AnswerInlineResult{
			Type:        AnswerInlineTypeVoice,
			ID:          "",
			VoiceFileId: &voice,
			Title:       "Come get some!",
			Caption:     "Come get some!",
		}
		expected.ID = answer.ID

		if !reflect.DeepEqual(answer, expected) {
			in.Errorf("\nexp: %+v\ngot: %+v", expected, answer)
		}
	})
}

func TestNewAnswerInline(t *testing.T) {
	originQuotes := Quotes
	defer func() {
		Quotes = originQuotes
	}()
	_ = ReadQuotes(testConfigFile)

	update := &Update{
		ID:          1337,
		InlineQuery: &InlineQuery{ID: "133733", Query: "bad"},
	}

	// check only answer identifier
	answer := NewAnswerInline(update)
	expectedID := "133733"
	if answer.ID != expectedID {
		t.Errorf("expected: %v, got: %v", expectedID, answer.ID)
	}
}
